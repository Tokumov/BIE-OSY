The task is to develop a set of classes that optimize truss structures.

Assume we need to construct a rigid structure. The structure needs to be as rigid as possible while we want to optimize its weight. One way to achieve the goal is to use a truss structure. We assume the structure is of a polygonal shape, the polygon may be non-convex. We add additional beams that connect some vertices of the polygon to enforce the polygon. To make the structure as rigid as possible, we add as many such additional beams as possible. The limitation is that the additional beams do not cross each other. In fact, the additional beams divide the polygon into disjoint triangles. The task is to find the configuration of the additional beams such that the sum of the lengths is the smallest possible. Formally, the problem is to find the minimum triangulation of the non-convex polygon.

The second problem is to find the total number of possible ways the triangles may be formed. For instance, a rectangle may be enforced in two ways: we add either one diagonal. The computation gets more tricky if the polygon has more vertices and has various shapes. The number of possible triangulations grows rather fast with increasing number of polygon vertices, thus the computation will be performed in custom 1024 bit wide integers.

Both problems may be solved in polynomial time with time complexity of O(n3). The complexity is rather high, thus it pays off to use more threads to speed up the computation. You are expected to develop a solution that integrates into the provided infrastructure: your code must create, schedule, synchronize, and terminate the required threads. The algorithmic solution is not needed. You may decide to implement the computation algorithm yourself or you may use a sequential solver provided in the Progtest environment.

An instance of CPolygon class is used to represent the problems to solve. The class contains member variables with the list of polygon vertices, the length of the minimal triangulation, and the number of triangulations. The latter two member variables are to be filled by the solver.

The problems are packed into groups, these are represented by class CProblemPack. The pack contains two independent list: one list contains the polygons where the triangulation needs to be computed, the second list contains the polygons where we need to compute the total number of triangulations.

Our optimizing service is viable for construction companies. We server several such companies, each such company is represented by an instance of class CCompany. The companies continuously generate CProblemPack instances to be solved. Class CCompany provides a method to access the next problem pack (method waitForPack) and a method to return the solved problem pack back (method solvedPack). To correctly handle the two methods, your implementation needs to start two auxiliary communication threads for each instance of CCompany. The first communication thread will receive the problem packs (it will call waitForPack in a loop and pass the received packs to further processing). The second communication thread will be used to pass the solved packs back (it will receive solved pack and call solvedPack). Apart from the communication, these two threads will not do any computation. The computation may take a lot of time while the communication threads are expected to promptly communicate with the company. On the other hand, the communication threads are expected to maintain the order of problem packs. The company expects to receive the solved packs in the same order it sent them. Our optimizer may (it is even expected to) read and process more than one problem pack simultaneously, however, it must preserve the order of problem packs when the solved packs are returned.

The computation is encapsulated in a COptimizer class instance. This class is given the references to the individual companies, it controls the execution, and it manages the worker threads. As stated above, the computation of the problems may be very time consuming. Communication threads are not intended to actually do the computation. Therefore, there will be dedicated worker threads that do the expensive computation job, leaving the communication threads free for the service of CCompany. A communication thread reads a CProblemPack instance from CCompany::waitForPack. The instance is passed to the worker threads, these threads compute the optimal minimal triangulation/count the possible triangulations. Once the computation is finished for all CPolygon instances, the completed CProblemPack instance is passed to the communication thread that serves method solvedPack of the originating company. The communication thread is responsible for the order of the problem packs (we need to preserve the same order given by the reading) and calls the solvedPack method when appropriate. The number of worker threads is controlled by an external parameter, thus the computation load may be adjusted to the hardware capabilities (e.g., the number of CPUs).

The following scenario describes the expected use of class COptimizer:

a new instance of COptimizer is created,
the companies are created and registered (method addCompany),
the computation is started (method start). The method is given the number of worker threads in its parameter. Method COptimizer::start runs the worker threads, and lets them wait for the work. Next, it runs the communication threads (two communication threads per registered company) and lets them serve the problem packs. Once all threads are initialized, the method returns to its caller,
the communication threads receive the problem packs from the companies (waitForPack) and pass them to the worker threads. When waitForPack returns an empty smart pointer, the corresponding company is not going to provide any further problems and the communication thread may leave the loop and terminate,
worker threads accept problems from the communication threads and solve them. When solved, the problems are passed back to the originating company (where the second communication thread returns them),
the second communication thread receives the solved instance of CProblemPack and returns it to the company (method solvedPack). The solved packs must be returned immediately when possible (still, we have to care about the order). In particular, you cannot save the received problems in an array and return all of them in a batch at the end of the computation. The submitting communication thread terminates when the last CProblemPack instance is returned to the company,
the testing environment calls COptimizer::stop. This call may be invoked at any moment, often even in the middle of the computation. Method COptimizer::stop waits until all problem packs are processed, all threads are terminated and returns to the caller,
COptimizer instance is freed.
The classes and their interface:
CPoint is a class that represents a vertex of a polygon. The class is very simple, there is a pair of integers representing the 2D coordinate. The class is implemented in the testing environment, you must not modify it in any way. The interface is:
m_X coordinate x,
m_Y coordinate y.
CPolygon is a class that represents a single problem to optimize. It aggregates the polygon vertices, the length of the minimal triangulation, and the total number of possible triangulations. The class is implemented in the testing environment, you are not allowed to modify it in any way (technically, the testing environment implements a subclass of CPolygon). The interface is:
m_Points the vertices of the polygon,
m_TriangMin the length of the minimal triangulation. The length sums the length of the polygon edges and the length of the additional enforcement beams. This member variable is initialized to 0, the correct value needs to be computed and filled if the polygon is listed in the minimum triangulation problems (see below),
m_TriangCnt the total number of possible triangulations. This member variable is initialized to 0, the correct value needs to be computed and filled if the polygon is listed in the count possible triangulation problems (see below),
there are some auxiliary methods that simplify the handling of the vertices, see the attached code.
CProblemPack is a list of problems to solve. The class is an abstract class, the testing environment implements and uses a subclass of CProblemPack. The implementation is fixed, you are not allowed to modify it in any way. The interface is:
m_ProblemsMin an array of problem instances; minimum triangulation needs to be computed for the listed polygons,
m_ProblemsCnt an array of problem instances; the total number of possible triangulation needs to be computed for the listed polygons,
methods addMin and addCnt that simplify the construction of the instance (see the attached code).
CCompany is a class that represents a company. The class is an abstract class, the actual implementation is hidden in the testing environment (i.e., your program will communicate with a subclass of CCompany). The interface is fixed, you cannot modify it in any way. The class provides methods:
waitForPack to read the next problem pack to solve. The method returns a smart pointer encapsulating CProblemPack instance, or an empty smart pointer to indicate that there are no further problems to process from that particular company. The call may block for a rather long time, therefore, you must call this method from a dedicated communication thread. The communication thread is expected to call this method in a loop and it is expected to pass the received problem packs to the worker threads. The testing environment tests that this method is called by exactly one communication thread. That is, for each instance of CCompany, there must exist a dedicated communication thread that calls this method,
solvedPack is a method to pass the computed instance of CProblemPack back to the company. The parameter is the solved instance previously read from waitForPack. The processing in solvedPack may block for a rather long time, therefore, each instance of CCompany must start a dedicated communication thread that receives solved problems from the worker threads and passes them back to the company. The testing environment tests that this method is called by exactly one communication thread. That is, for each instance of CCompany, there must exist a dedicated communication thread that calls this method. The communication thread must take care of the order the solved instances are passed to the company. The company expects the computed problem packs in the same order they were read from waitForPack.
CBigInt is a class that implements big positive integers. The numbers are represented in a binary form, the capacity is 1024 bits. The class is implemented in the testing environment and is provided in the attached library. The implementation is limited to some basic operations:
set a value (either from uint64_t, or from a string with decimal representation),
convert the integer into a textual representation (a string in decimal notation),
addition,
multiplication,
comparison.
There are not any other operations, in fact, no further operations are needed.
COptimizer is an encapsulating class. You are expected to develop the class and implement the required interface:
a default constructor to initialize the instance. The constructor is not expected to start any threads,
method addCompany (x), the method adds a new instance of the company,
method start ( workThr ), the method starts the communication and worker threads. Once the threads are started, method start returns to the caller,
method stop, the method waits until all problems (from all registered companies) are processed and then terminates all threads. Finally, it returns to the caller,
method usingProgtestSolver() returns true if you use the delivered solver (CProgtestSolver) or false if you implement the solver yourself. If you return true, then the testing environment does not call method COptimizer::checkAlgorithmMin (p) / COptimizer::checkAlgorithmCnt (p) below (you may leave these methods empty). Conversely, if the method returns false, then the testing environment disables the built-in solved in CProgtestSolver - the solver computes invalid results if used in this case.
static method checkAlgorithmMin(p). The method is intended to check the correctness of the computation algorithms. A parameter to this call is an instance of CPolygon, the method needs to sequentially solve the minimal triangulation and save the result in the m_TriangMin member. This method is also used to calibrate the speed of your implementation. The testing environment measures the speed, this measurement is used to modify the size of the problems it generates. Implement this method if you do not use the built-in solver in CProgtestSolver (i.e., implement this method when COptimizer::usingProgtestSolver() returns false).
static method checkAlgorithmCnt(p). The method is similar to the checkAlgorithmMin(p) method. The difference is this method needs to compute the number of possible triangulations and store the result into the m_TriangCnt member.
CProgtestSolver is a class that provides a sequential solver of both triangulation problems. The class and its interface is a bit playful. This provides a good opportunity to have some extra fun when using the class. Class CProgtestSolver is an abstract class, the implementation is hidden in its subclass. In fact, the testing environment (and the attached library) provide two subclasses of CProgtestSolver: one subclass computes the minimum triangulation while the second computes the possible triangulations. The instances of the solver are created by two factory functions: createProgtestMinSolver() creates an instance that solves minimal triangulations and createProgtestCntSolver() counts the possible triangulations. CProgtestSolver solves the problems in batches. Each CProgtestSolver is assigned a certain capacity, the capacity limits the maximum number of problems the instance is willing to solve. CProgtestSolver instance is one-shot: you fill the problem instances and trigger the computation. When finished, the solver instance is no longer of any use (it refuses to do anything more). New CProgtestSolver instance must be created if there are further problems to solve. The interface is:
hasFreeCapacity() the method returns true, if there is a free space for next CPolygon instance or false if the solver instance is completely full,
addPolygon(x) the method adds problem x to solve. Return value is either true (problem added), or false (problem not added, at the capacity limit). A good strategy is to test the capacity (hasFreeCapacity) after each addProblem call. If the capacity is completely used, start the computation (method solve() below).
solve() the method runs the computation itself. The minimal triangulation/possible triangulations are computed and saved into the corresponding CPolygon instances, i.e., the computation fills in the CPolygon::m_TriangMin / CPolygon::m_TriangCnt fields. The computation does not do anything else, in particular, it does not inform the companies (does not call CCompany::solvedPack). Any further processing of the solved problems is left on you. Method solve may be called only once for CProgtestSolver instance, further calls end with an error. The method returns the number of solved problems, return value of 0 typically means an error (e.g., repeated call to the solve() method).
CProgtestSolver instance has a limit on its capacity. Any attempt to exceed the capacity results in an error (addProblem fails). On the other hand, method solve may be called at any moment (however, only once for each instance). Nevertheless, do not try to abuse this and solve problem instances one by one:

there is a limit on the created CProgtestSolver instances. The testing environment knows the number of problems it generates (N). Subsequently, it creates CProgtestSolver instances and sets their capacities such that the sum of the capacities is M. It guarantees that M greater or equal to N. However, M is not much bigger than N,
if you used CProgtestSolver instances to only solve one problem, you are going to exhaust the total capacity M soon. There will not be any capacity left to solve the further problems,
if you exhaust the capacity M, subsequent calls to createProgtestSolver() will return unusable CProgtestSolver instances (based on the Progtest mood: empty smart pointer, solver with zero capacity, or solver that fills invalid results),
therefore, you need to fully use the capacity of the created solver instances,
the capacities of the solvers are chosen randomly. As stated above, the solver is intended to add some fun to the programming,
Finally, the solver in the testing environment is only available in the mandatory and optional tests (it is not available in the bonus tests). If you call factory functions createProgtestMinSolver() / createProgtestCntSolver() in a bonus test, the returned smart pointer may be empty, the solver may have zero capacity, or the solver may be malfunctioning.

Submit your source code containing the implementation of class COptimizer with the required interface. You can add additional classes and functions, of course. Do not include function main nor #include directives to your implementation. The function main and #include directives can be included only if they are part of the conditional compile directive block (#ifdef / #ifndef / #endif).

Use the example implementation file included in the attached archive. Your whole implementation needs to be part of source file solution.cpp. If you preserve compiler directives, you can submit file solution.cpp as a solution.

You can use pthread or C++11 thread API for your implementation (see available #include files). The Progtest uses g++ compiler version 12.2, this version handles most of the C++11, C++14, C++17, and C++20 constructs correctly (there are some minor unsupported C++20 features).
